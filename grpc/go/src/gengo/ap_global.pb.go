// Code generated by protoc-gen-go. DO NOT EDIT.
// source: ap_global.proto

package cheetah

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Global Event Notification types.
type APGlobalNotifType int32

const (
	// Reserved. 0x0
	APGlobalNotifType_AP_GLOBAL_EVENT_TYPE_RESERVED APGlobalNotifType = 0
	// Error. ErrStatus field elaborates on the message. 0x1
	APGlobalNotifType_AP_GLOBAL_EVENT_TYPE_ERROR APGlobalNotifType = 1
	// HeartBeat. 0x2
	APGlobalNotifType_AP_GLOBAL_EVENT_TYPE_HEARTBEAT APGlobalNotifType = 2
	// Version. APInitMsgRsp field elaborates on the server version. 0x3
	APGlobalNotifType_AP_GLOBAL_EVENT_TYPE_VERSION APGlobalNotifType = 3
	// Configuration. 0x4
	APGlobalNotifType_AP_GLOBAL_EVENT_TYPE_CONFIG APGlobalNotifType = 4
)

var APGlobalNotifType_name = map[int32]string{
	0: "AP_GLOBAL_EVENT_TYPE_RESERVED",
	1: "AP_GLOBAL_EVENT_TYPE_ERROR",
	2: "AP_GLOBAL_EVENT_TYPE_HEARTBEAT",
	3: "AP_GLOBAL_EVENT_TYPE_VERSION",
	4: "AP_GLOBAL_EVENT_TYPE_CONFIG",
}
var APGlobalNotifType_value = map[string]int32{
	"AP_GLOBAL_EVENT_TYPE_RESERVED":  0,
	"AP_GLOBAL_EVENT_TYPE_ERROR":     1,
	"AP_GLOBAL_EVENT_TYPE_HEARTBEAT": 2,
	"AP_GLOBAL_EVENT_TYPE_VERSION":   3,
	"AP_GLOBAL_EVENT_TYPE_CONFIG":    4,
}

func (x APGlobalNotifType) String() string {
	return proto.EnumName(APGlobalNotifType_name, int32(x))
}
func (APGlobalNotifType) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

// Initialization message sent to the server.
// If the client and server are running compatible version numbers, a
// connection will be made and the server response will be received
// with a successful status code.
type APInitMsg struct {
	// Client's Major version of service-layer API (refer to ap_version.proto)
	MajorVer uint32 `protobuf:"varint,1,opt,name=MajorVer" json:"MajorVer,omitempty"`
	// Minor Version
	MinorVer uint32 `protobuf:"varint,2,opt,name=MinorVer" json:"MinorVer,omitempty"`
	// Sub-Version
	SubVer uint32 `protobuf:"varint,3,opt,name=SubVer" json:"SubVer,omitempty"`
}

func (m *APInitMsg) Reset()                    { *m = APInitMsg{} }
func (m *APInitMsg) String() string            { return proto.CompactTextString(m) }
func (*APInitMsg) ProtoMessage()               {}
func (*APInitMsg) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *APInitMsg) GetMajorVer() uint32 {
	if m != nil {
		return m.MajorVer
	}
	return 0
}

func (m *APInitMsg) GetMinorVer() uint32 {
	if m != nil {
		return m.MinorVer
	}
	return 0
}

func (m *APInitMsg) GetSubVer() uint32 {
	if m != nil {
		return m.SubVer
	}
	return 0
}

// Server's response to the APInitMsg.
// On Success (ErrStatus), the session with the server is established
// and the client is allowed to proceed.
type APInitMsgRsp struct {
	// Server's version of access point API (refer to ap_version.proto)
	// Major-number revisions are NOT backwards compatible,
	// unless otherwise specified. The Server may reject a session if there
	// is a version number mismatch or non-backwards compatibility.
	MajorVer uint32 `protobuf:"varint,1,opt,name=MajorVer" json:"MajorVer,omitempty"`
	// Minor Version
	MinorVer uint32 `protobuf:"varint,2,opt,name=MinorVer" json:"MinorVer,omitempty"`
	// Sub-Version
	SubVer uint32 `protobuf:"varint,3,opt,name=SubVer" json:"SubVer,omitempty"`
}

func (m *APInitMsgRsp) Reset()                    { *m = APInitMsgRsp{} }
func (m *APInitMsgRsp) String() string            { return proto.CompactTextString(m) }
func (*APInitMsgRsp) ProtoMessage()               {}
func (*APInitMsgRsp) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *APInitMsgRsp) GetMajorVer() uint32 {
	if m != nil {
		return m.MajorVer
	}
	return 0
}

func (m *APInitMsgRsp) GetMinorVer() uint32 {
	if m != nil {
		return m.MinorVer
	}
	return 0
}

func (m *APInitMsgRsp) GetSubVer() uint32 {
	if m != nil {
		return m.SubVer
	}
	return 0
}

// Configuration message response.
// The server could send this message any time the application configuration
// gets changed.
type APCfgMsgRsp struct {
	// Token string
	Token string `protobuf:"bytes,1,opt,name=Token" json:"Token,omitempty"`
	// Proxy URL
	ProxyURL string `protobuf:"bytes,2,opt,name=ProxyURL" json:"ProxyURL,omitempty"`
	// Proxy Port
	ProxyPort uint32 `protobuf:"varint,3,opt,name=ProxyPort" json:"ProxyPort,omitempty"`
}

func (m *APCfgMsgRsp) Reset()                    { *m = APCfgMsgRsp{} }
func (m *APCfgMsgRsp) String() string            { return proto.CompactTextString(m) }
func (*APCfgMsgRsp) ProtoMessage()               {}
func (*APCfgMsgRsp) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *APCfgMsgRsp) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *APCfgMsgRsp) GetProxyURL() string {
	if m != nil {
		return m.ProxyURL
	}
	return ""
}

func (m *APCfgMsgRsp) GetProxyPort() uint32 {
	if m != nil {
		return m.ProxyPort
	}
	return 0
}

// Globals query message.
type APGlobalNotif struct {
	// Event Type.
	EventType APGlobalNotifType `protobuf:"varint,1,opt,name=EventType,enum=cheetah.APGlobalNotifType" json:"EventType,omitempty"`
	// Status code, interpreted based on the Event Type.
	//
	//   case EventType == AP_GLOBAL_EVENT_TYPE_ERROR:
	//       case ErrStatus == AP_NOTIF_TERM:
	//          => Another client is attempting to take over the session.
	//             This session will be closed.
	//       case ErrStatus == (some error from APErrorStatus)
	//          => Client must look into the specific error message returned.
	//
	//   case EventType == AP_GLOBAL_EVENT_TYPE_HEARTBEAT:
	//       case ErrStatus == AP_SUCCESS
	//          => Client can safely ignore this heartbeat message.
	//
	//   case EventType == AP_GLOBAL_EVENT_TYPE_VERSION:
	//       case ErrStatus == AP_SUCCESS
	//          => Client version accepted.
	//       case ErrStatus == AP_INIT_STATE_READY
	//          => Client version accepted.
	//             Any previous state was sucessfully recovered.
	//       case ErrStatus == AP_INIT_STATE_CLEAR
	//          => Client version accepted. Any previous state was lost.
	//             Client must replay all previous objects to server.
	//       case ErrStatus == AP_UNSUPPORTED_VER
	//          => Client and Server version mismatch. The client is not
	//             allowed to proceed, and the channel will be closed.
	//       case ErrStatus == (some error from APErrorStatus)
	//          => Client must either try again, or look into the specific
	//             error message returned.
	ErrStatus *APErrorStatus `protobuf:"bytes,2,opt,name=ErrStatus" json:"ErrStatus,omitempty"`
	// Further info based on EventType.
	//
	// Types that are valid to be assigned to Event:
	//	*APGlobalNotif_InitRspMsg
	//	*APGlobalNotif_CfgRspMsg
	Event isAPGlobalNotif_Event `protobuf_oneof:"Event"`
}

func (m *APGlobalNotif) Reset()                    { *m = APGlobalNotif{} }
func (m *APGlobalNotif) String() string            { return proto.CompactTextString(m) }
func (*APGlobalNotif) ProtoMessage()               {}
func (*APGlobalNotif) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

type isAPGlobalNotif_Event interface {
	isAPGlobalNotif_Event()
}

type APGlobalNotif_InitRspMsg struct {
	InitRspMsg *APInitMsgRsp `protobuf:"bytes,3,opt,name=InitRspMsg,oneof"`
}
type APGlobalNotif_CfgRspMsg struct {
	CfgRspMsg *APCfgMsgRsp `protobuf:"bytes,4,opt,name=CfgRspMsg,oneof"`
}

func (*APGlobalNotif_InitRspMsg) isAPGlobalNotif_Event() {}
func (*APGlobalNotif_CfgRspMsg) isAPGlobalNotif_Event()  {}

func (m *APGlobalNotif) GetEvent() isAPGlobalNotif_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *APGlobalNotif) GetEventType() APGlobalNotifType {
	if m != nil {
		return m.EventType
	}
	return APGlobalNotifType_AP_GLOBAL_EVENT_TYPE_RESERVED
}

func (m *APGlobalNotif) GetErrStatus() *APErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

func (m *APGlobalNotif) GetInitRspMsg() *APInitMsgRsp {
	if x, ok := m.GetEvent().(*APGlobalNotif_InitRspMsg); ok {
		return x.InitRspMsg
	}
	return nil
}

func (m *APGlobalNotif) GetCfgRspMsg() *APCfgMsgRsp {
	if x, ok := m.GetEvent().(*APGlobalNotif_CfgRspMsg); ok {
		return x.CfgRspMsg
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*APGlobalNotif) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _APGlobalNotif_OneofMarshaler, _APGlobalNotif_OneofUnmarshaler, _APGlobalNotif_OneofSizer, []interface{}{
		(*APGlobalNotif_InitRspMsg)(nil),
		(*APGlobalNotif_CfgRspMsg)(nil),
	}
}

func _APGlobalNotif_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*APGlobalNotif)
	// Event
	switch x := m.Event.(type) {
	case *APGlobalNotif_InitRspMsg:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InitRspMsg); err != nil {
			return err
		}
	case *APGlobalNotif_CfgRspMsg:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CfgRspMsg); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("APGlobalNotif.Event has unexpected type %T", x)
	}
	return nil
}

func _APGlobalNotif_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*APGlobalNotif)
	switch tag {
	case 3: // Event.InitRspMsg
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(APInitMsgRsp)
		err := b.DecodeMessage(msg)
		m.Event = &APGlobalNotif_InitRspMsg{msg}
		return true, err
	case 4: // Event.CfgRspMsg
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(APCfgMsgRsp)
		err := b.DecodeMessage(msg)
		m.Event = &APGlobalNotif_CfgRspMsg{msg}
		return true, err
	default:
		return false, nil
	}
}

func _APGlobalNotif_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*APGlobalNotif)
	// Event
	switch x := m.Event.(type) {
	case *APGlobalNotif_InitRspMsg:
		s := proto.Size(x.InitRspMsg)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *APGlobalNotif_CfgRspMsg:
		s := proto.Size(x.CfgRspMsg)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Globals query message.
type APGlobalsGetMsg struct {
}

func (m *APGlobalsGetMsg) Reset()                    { *m = APGlobalsGetMsg{} }
func (m *APGlobalsGetMsg) String() string            { return proto.CompactTextString(m) }
func (*APGlobalsGetMsg) ProtoMessage()               {}
func (*APGlobalsGetMsg) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

// Platform specific globals Response.
type APGlobalsGetMsgRsp struct {
	// Corresponding error code
	ErrStatus *APErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus" json:"ErrStatus,omitempty"`
	// Maximum radio name length
	MaxRadioNameLength uint32 `protobuf:"varint,2,opt,name=MaxRadioNameLength" json:"MaxRadioNameLength,omitempty"`
	// Maximum ssid name length
	MaxSsidNameLength uint32 `protobuf:"varint,3,opt,name=MaxSsidNameLength" json:"MaxSsidNameLength,omitempty"`
}

func (m *APGlobalsGetMsgRsp) Reset()                    { *m = APGlobalsGetMsgRsp{} }
func (m *APGlobalsGetMsgRsp) String() string            { return proto.CompactTextString(m) }
func (*APGlobalsGetMsgRsp) ProtoMessage()               {}
func (*APGlobalsGetMsgRsp) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{5} }

func (m *APGlobalsGetMsgRsp) GetErrStatus() *APErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

func (m *APGlobalsGetMsgRsp) GetMaxRadioNameLength() uint32 {
	if m != nil {
		return m.MaxRadioNameLength
	}
	return 0
}

func (m *APGlobalsGetMsgRsp) GetMaxSsidNameLength() uint32 {
	if m != nil {
		return m.MaxSsidNameLength
	}
	return 0
}

func init() {
	proto.RegisterType((*APInitMsg)(nil), "cheetah.APInitMsg")
	proto.RegisterType((*APInitMsgRsp)(nil), "cheetah.APInitMsgRsp")
	proto.RegisterType((*APCfgMsgRsp)(nil), "cheetah.APCfgMsgRsp")
	proto.RegisterType((*APGlobalNotif)(nil), "cheetah.APGlobalNotif")
	proto.RegisterType((*APGlobalsGetMsg)(nil), "cheetah.APGlobalsGetMsg")
	proto.RegisterType((*APGlobalsGetMsgRsp)(nil), "cheetah.APGlobalsGetMsgRsp")
	proto.RegisterEnum("cheetah.APGlobalNotifType", APGlobalNotifType_name, APGlobalNotifType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for APGlobal service

type APGlobalClient interface {
	// Initialize the connection, and setup a notification channel.
	// This MUST be the first call to setup the Access Point connection.
	//
	// The caller MUST maintain the notification channel to be able to
	// communicate with the server.
	// If this channel is not properly established and maintained, all other
	// RPC requests are rejected.
	//
	// The caller must send its version information as part of the APInitMsg
	// message. The server will reply with AP_GLOBAL_EVENT_TYPE_VERSION
	// that tells the caller whether he can proceed or not.
	// Refer to message APGlobalNotif below for further details.
	//
	// After the version handshake, the notification channel is used for
	// "push" event notifications, such as:
	//    - APGlobalNotif.EventType = AP_GLOBAL_EVENT_TYPE_HEARTBEAT
	//        heartbeat notification messages are sent to the client on
	//        a periodic basis.
	//    Refer to APGlobalNotif definition for further info.
	APGlobalInitNotif(ctx context.Context, in *APInitMsg, opts ...grpc.CallOption) (APGlobal_APGlobalInitNotifClient, error)
	// Get platform specific globals
	APGlobalsGet(ctx context.Context, in *APGlobalsGetMsg, opts ...grpc.CallOption) (*APGlobalsGetMsgRsp, error)
}

type aPGlobalClient struct {
	cc *grpc.ClientConn
}

func NewAPGlobalClient(cc *grpc.ClientConn) APGlobalClient {
	return &aPGlobalClient{cc}
}

func (c *aPGlobalClient) APGlobalInitNotif(ctx context.Context, in *APInitMsg, opts ...grpc.CallOption) (APGlobal_APGlobalInitNotifClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_APGlobal_serviceDesc.Streams[0], c.cc, "/cheetah.APGlobal/APGlobalInitNotif", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPGlobalAPGlobalInitNotifClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type APGlobal_APGlobalInitNotifClient interface {
	Recv() (*APGlobalNotif, error)
	grpc.ClientStream
}

type aPGlobalAPGlobalInitNotifClient struct {
	grpc.ClientStream
}

func (x *aPGlobalAPGlobalInitNotifClient) Recv() (*APGlobalNotif, error) {
	m := new(APGlobalNotif)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPGlobalClient) APGlobalsGet(ctx context.Context, in *APGlobalsGetMsg, opts ...grpc.CallOption) (*APGlobalsGetMsgRsp, error) {
	out := new(APGlobalsGetMsgRsp)
	err := grpc.Invoke(ctx, "/cheetah.APGlobal/APGlobalsGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for APGlobal service

type APGlobalServer interface {
	// Initialize the connection, and setup a notification channel.
	// This MUST be the first call to setup the Access Point connection.
	//
	// The caller MUST maintain the notification channel to be able to
	// communicate with the server.
	// If this channel is not properly established and maintained, all other
	// RPC requests are rejected.
	//
	// The caller must send its version information as part of the APInitMsg
	// message. The server will reply with AP_GLOBAL_EVENT_TYPE_VERSION
	// that tells the caller whether he can proceed or not.
	// Refer to message APGlobalNotif below for further details.
	//
	// After the version handshake, the notification channel is used for
	// "push" event notifications, such as:
	//    - APGlobalNotif.EventType = AP_GLOBAL_EVENT_TYPE_HEARTBEAT
	//        heartbeat notification messages are sent to the client on
	//        a periodic basis.
	//    Refer to APGlobalNotif definition for further info.
	APGlobalInitNotif(*APInitMsg, APGlobal_APGlobalInitNotifServer) error
	// Get platform specific globals
	APGlobalsGet(context.Context, *APGlobalsGetMsg) (*APGlobalsGetMsgRsp, error)
}

func RegisterAPGlobalServer(s *grpc.Server, srv APGlobalServer) {
	s.RegisterService(&_APGlobal_serviceDesc, srv)
}

func _APGlobal_APGlobalInitNotif_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(APInitMsg)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APGlobalServer).APGlobalInitNotif(m, &aPGlobalAPGlobalInitNotifServer{stream})
}

type APGlobal_APGlobalInitNotifServer interface {
	Send(*APGlobalNotif) error
	grpc.ServerStream
}

type aPGlobalAPGlobalInitNotifServer struct {
	grpc.ServerStream
}

func (x *aPGlobalAPGlobalInitNotifServer) Send(m *APGlobalNotif) error {
	return x.ServerStream.SendMsg(m)
}

func _APGlobal_APGlobalsGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(APGlobalsGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APGlobalServer).APGlobalsGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cheetah.APGlobal/APGlobalsGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APGlobalServer).APGlobalsGet(ctx, req.(*APGlobalsGetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _APGlobal_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cheetah.APGlobal",
	HandlerType: (*APGlobalServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "APGlobalsGet",
			Handler:    _APGlobal_APGlobalsGet_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "APGlobalInitNotif",
			Handler:       _APGlobal_APGlobalInitNotif_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "ap_global.proto",
}

func init() { proto.RegisterFile("ap_global.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 516 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x54, 0x5d, 0x6f, 0xd3, 0x30,
	0x14, 0x6d, 0xf6, 0x9d, 0x5b, 0xc6, 0x5a, 0x6b, 0xab, 0xa6, 0x6c, 0x8c, 0x91, 0x27, 0x84, 0x50,
	0x85, 0x0a, 0x12, 0xbc, 0xa6, 0xc5, 0xb4, 0x95, 0xfa, 0x11, 0x39, 0xa1, 0x12, 0x42, 0x10, 0xb9,
	0x9b, 0x9b, 0x06, 0xd6, 0x38, 0x4a, 0x3c, 0xd4, 0xfe, 0x0f, 0x7e, 0x04, 0x7f, 0x82, 0xdf, 0xc5,
	0x2b, 0x8a, 0xe3, 0x35, 0x19, 0x0d, 0x12, 0x0f, 0xbc, 0xf5, 0xfa, 0x9c, 0x7b, 0x7c, 0xef, 0x39,
	0x6e, 0xe0, 0x88, 0x46, 0x9e, 0x7f, 0xc3, 0xa7, 0xf4, 0xa6, 0x19, 0xc5, 0x5c, 0x70, 0xb4, 0x7f,
	0x35, 0x67, 0x4c, 0xd0, 0xb9, 0x71, 0x42, 0x23, 0xef, 0x8a, 0x2f, 0x16, 0x3c, 0xf4, 0xc4, 0x2a,
	0x62, 0x49, 0x86, 0x9b, 0x1f, 0x41, 0xb7, 0xec, 0x7e, 0x18, 0x88, 0x61, 0xe2, 0x23, 0x03, 0x0e,
	0x86, 0xf4, 0x0b, 0x8f, 0x27, 0x2c, 0x3e, 0xd5, 0x2e, 0xb5, 0xa7, 0x87, 0x64, 0x5d, 0x4b, 0x2c,
	0x08, 0x33, 0x6c, 0x4b, 0x61, 0xaa, 0x46, 0x0d, 0xd8, 0x73, 0x6e, 0xa7, 0x29, 0xb2, 0x2d, 0x11,
	0x55, 0x99, 0x9f, 0xe1, 0xc1, 0x5a, 0x9c, 0x24, 0xd1, 0x7f, 0xd7, 0xff, 0x04, 0x55, 0xcb, 0xee,
	0xcc, 0x7c, 0x25, 0x7f, 0x0c, 0xbb, 0x2e, 0xff, 0xca, 0x42, 0xa9, 0xad, 0x93, 0xac, 0x48, 0x85,
	0xed, 0x98, 0x2f, 0x57, 0xef, 0xc9, 0x40, 0x0a, 0xeb, 0x64, 0x5d, 0xa3, 0x73, 0xd0, 0xe5, 0x6f,
	0x9b, 0xc7, 0x42, 0x69, 0xe7, 0x07, 0xe6, 0x2f, 0x0d, 0x0e, 0x2d, 0xbb, 0x2b, 0xed, 0x1c, 0x71,
	0x11, 0xcc, 0xd0, 0x1b, 0xd0, 0xf1, 0x37, 0x16, 0x0a, 0x77, 0x15, 0x31, 0x79, 0xcb, 0xc3, 0x96,
	0xd1, 0x54, 0x0e, 0x37, 0xef, 0x51, 0x53, 0x06, 0xc9, 0xc9, 0xe8, 0x15, 0xe8, 0x38, 0x8e, 0x1d,
	0x41, 0xc5, 0x6d, 0x22, 0xc7, 0xa8, 0xb6, 0x1a, 0x85, 0x4e, 0x1c, 0xc7, 0x5c, 0xa1, 0x24, 0x27,
	0xa2, 0xd7, 0x00, 0xa9, 0x7d, 0x24, 0x89, 0x86, 0x89, 0x2f, 0x07, 0xac, 0xb6, 0x4e, 0x0a, 0x6d,
	0xb9, 0xb7, 0xbd, 0x0a, 0x29, 0x50, 0xd3, 0xeb, 0x3a, 0x33, 0x5f, 0xf5, 0xed, 0xc8, 0xbe, 0xe3,
	0x42, 0xdf, 0xda, 0xb3, 0x5e, 0x85, 0xe4, 0xc4, 0xf6, 0x3e, 0xec, 0xca, 0x89, 0xcd, 0x3a, 0x1c,
	0xdd, 0x6d, 0x93, 0x74, 0x59, 0x7a, 0x85, 0xf9, 0x43, 0x03, 0xf4, 0xc7, 0x59, 0xea, 0xf9, 0xbd,
	0xbd, 0xb4, 0x7f, 0xdd, 0xab, 0x09, 0x68, 0x48, 0x97, 0x84, 0x5e, 0x07, 0x7c, 0x44, 0x17, 0x6c,
	0xc0, 0x42, 0x5f, 0xcc, 0x55, 0xec, 0x25, 0x08, 0x7a, 0x0e, 0xf5, 0x21, 0x5d, 0x3a, 0x49, 0x70,
	0x5d, 0xa0, 0x67, 0x79, 0x6d, 0x02, 0xcf, 0x7e, 0x6a, 0x50, 0xdf, 0x08, 0x03, 0x3d, 0x81, 0x47,
	0x96, 0xed, 0x75, 0x07, 0xe3, 0xb6, 0x35, 0xf0, 0xf0, 0x04, 0x8f, 0x5c, 0xcf, 0xfd, 0x60, 0x63,
	0x8f, 0x60, 0x07, 0x93, 0x09, 0x7e, 0x5b, 0xab, 0xa0, 0x0b, 0x30, 0x4a, 0x29, 0x98, 0x90, 0x31,
	0xa9, 0x69, 0xc8, 0x84, 0x8b, 0x52, 0xbc, 0x87, 0x2d, 0xe2, 0xb6, 0xb1, 0xe5, 0xd6, 0xb6, 0xd0,
	0x25, 0x9c, 0x97, 0x72, 0x26, 0x98, 0x38, 0xfd, 0xf1, 0xa8, 0xb6, 0x8d, 0x1e, 0xc3, 0x59, 0x29,
	0xa3, 0x33, 0x1e, 0xbd, 0xeb, 0x77, 0x6b, 0x3b, 0xad, 0xef, 0x1a, 0x1c, 0xdc, 0xcd, 0x8f, 0xac,
	0x7c, 0x97, 0x34, 0xdf, 0xec, 0x1d, 0xa2, 0xcd, 0x37, 0x60, 0x34, 0xca, 0x1f, 0xe2, 0x0b, 0x0d,
	0xe1, 0xf4, 0x6f, 0x98, 0x27, 0x87, 0x4e, 0x37, 0x98, 0x2a, 0x50, 0xe3, 0xec, 0x6f, 0x08, 0x49,
	0xa2, 0xe9, 0x9e, 0xfc, 0x62, 0xbc, 0xfc, 0x1d, 0x00, 0x00, 0xff, 0xff, 0xe5, 0x22, 0xc7, 0x42,
	0x64, 0x04, 0x00, 0x00,
}
